# 14장 전역 변수의 문제점

전역변수를 반드시 사용해야하는 이유를 찾지 못한다면 지역 변수를 사용해야 한다

## 변수의 생명 주기

함수 내부에서 선언된 지역변수는 함수가 호출되면 생성, 함수가 종료되면 소멸

변수 선언은 코드 런타임 이전 단계 자바스크립트 엔진에 의해 먼저 실행 (전역 변수 한정)

지역변수의 생명 주기 = 함수의 생명 주기

### 전역 변수 생명주기

코드가 로드되자마자 곧바로 해석되고 실행됨

var 키워드로 선언한 전역변수 = 전역 객체의 프로퍼티 → 전역 변수 생명 주기 = 전역 객체 생명 주기

## 전역 변수의 문제점

- 암묵적 결합
  - 코드 어디서든 전역 변수를 참조하고 변경 가능
  - 변수 유효 범위 ⬆️, 코드 가독성 ⬇️, 의도하지 않은 상태 변경 위험성 ⬆️
- 긴 생명 주기
  - 메모리 리소스 오랜 기간 동안 소비
  - 변수 이름 중복시 의도치 않은 재할당 발생
- 스코프 체인 상에서 종점에 존재
  - 전역 변수의 검색 속도가 가장 느림
- 네임스페이스 오염
  - 다른 파일에서 동일한 이름으로 명명된 전역 변수나 함수가 같은 스코프내에 존재 시 예상 못한 결과 발생할 수도

## 전역 변수의 사용을 억제하는 방법

전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수 사용

변수의 스코프는 좁을수록 좋음

### 1. 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉실 실행 함수의 지역 변수가 됨

```jsx
(function () {
  var foo = 10; // 즉시 실행 함수의 지역 변수
  // ...
})();

console.log(foo); // ReferenceError: foo is not defined
```

→ 라이브러리에 자주 사용

### 2. 네임스페이스 객체

- 전역에 네임스페이스 역할을 담당할 객체를 생성
- 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가
- 네임스페이스 객체에 또 다른 네임스페이스 객체를 프로퍼티로 추가(계층적으로 구성)

→ 식별자 충돌 방지 효과 O, 유용X

### 3. 모듈 패턴

: 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 패턴

- 클로저 기반으로 동작
- 전역 변수 억제 가능
- 캡슐화 구현 가능
- 정보 은닉 구현하기 위해 사용

```jsx
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

객체 프로퍼티 = 외부에 노출되는 public 멤버

반환하는 객체 추가 X = private 멤버

### 4. ES6 모듈

파일 자체의 독자적인 모듈 스코프 제공

`script` 태그에 `type=”module”` 어트리뷰트를 추가하면 로드된 js 파일은 모듈로서 동작

- 어트리뷰트
  자바스크립트 어트리뷰트(Attribute)는 HTML 요소에 대한 추가적인 정보를 제공하는 속성
  HTML 태그의 시작 태그에 추가
  보통 속성의 값으로 특정한 동작이나 동작에 대한 정보를 전달
